Corrective changes such as bug fixes are frequently applied by developers to eliminate defects in software. There are mainly two lines of research conducted: (1) empirical studies to characterize bugs and corresponding fixes~\cite{Fenton2000:QAF,Li2006:TCE,Kim2006:MBF,Lu2008:LMC,Nguyen2010:RBF,Yin2011:FBB,Park2012:supplementary,Zhong2015:ESR}, and (2) automatic approaches to detect and fix such bugs~\cite{Engler2000:CSR,Bush2000:SAF,Hangal2002:TDS,Hovemeyer2004:FBE,Naik2006:ESR,Weimer2009:AFP}. There is no clear boundary between the two lines of research, because some prior projects~\cite{Li2006:CPMiner,Pham2010:DRS,Jin2012:UDR,Kim2013:PAR} first make observations about particular kinds of bug fixes empirically and then subsequently leverage their observed characteristics to find to automatically detect and fix bugs.

\subsubsection{Empirical Studies of Bug Fixes.}
In this section, we discuss two representative examples of empirical studies on bug fixes: (1) a large scale categorization and quantification of bug fixes, and (2) a study of bug fix histories. 
 
Li et al.~conducted an empirical study of bugs from two popular open source projects: Mozilla and Apache HTTP Server~\cite{Li2006:TCE}. By manually examining 264 bug reports from the Mozilla Bugzilla database~\cite{mozilla}, and 209 bug reports from the Apache Bugzilla database~\cite{asf}, they investigated the root cause, impact, and software components of each software error that exhibited abnormal runtime behaviors. They observed three major root causes: memory, concurrency, and semantics. The memory bugs account for 16.3\% in Mozilla and 12.2\% in Apache. Among memory bugs, NULL pointer dereference was observed as a major cause, accounting for 37.2 to 41.7\%. More importantly, semantic bugs are observed to be dominant, accounting for 81.1\% in Mozilla and 86.7\% in Apache. One possible reason is that most semantic bugs are specific to applications. A developer can easily introduce semantic bugs while coding, due to a lack of thorough understanding of the software and its requirements. It is challenging to automatically detect or fix such semantic bugs, because diagnosing and resolving them may require a lot of domain-specific knowledge and such knowledge is inherently not generalizable across different systems and applications.   

To understand the characteristics and frequency of project-specific bug fixes, Kim et al.~conduct an empirical study on the bug fix history of five open source projects: ArgoUML, Columba, Eclipse, jEdit, and Scarab~\cite{Kim2006:MBF}. With keywords like ``Fixed'' or ``Bugs'', they retrieved code commits in software version history that are relevant to bug fixes, chopped each commit into contiguous code change blocks (i.e., hunks), and then clustered similar code changes. They observed that 19.3 to 40.3\% bugs appeared repeatedly in version history, while 7.9 to 15.5\% of bug-and-fix pairs appeared more than once. The results demonstrate that project-specific bug fix patterns occur frequently enough to be useful as a bug detection technique. Furthermore, for the bug-and-fix pairs, it is possible to both detect the same bug and provide a fix suggestion based on prior fixes. 

\begin{table}[]
\centering
\caption{Sample system rule templates and examples from~\cite{Engler2000:CSR}}
\label{tab:rule}
\begin{tabular}{l|l}
\toprule
Rule template                  & Example                                                 \\ \hline
``Never/always do X''          & ``Do not use floating point in the kernel''             \\\hline
``Do X rather than Y''         & ``Use memory mapped I/O rather than copying''           \\ \hline
``Always do X before/after Y'' & ``Check user pointers before using them in the kernel''\\
\bottomrule
\end{tabular}
\end{table} 

\subsubsection{Rule-based Bug Detection and Fixing Approaches.}
Engler et al.~define a meta-language for users to easily specify temporal system rules such as ``release locks after acquiring them''~\cite{Engler2000:CSR}. They also extend a compiler to interpret the rules and dynamically generate additional checks in the compiler. If any code snippet violates the specified rule(s), the approach reports the snippet as a software bug. Table~\ref{tab:rule} presents some exemplar system rule templates and instances. 
With this approach, developers can flexibly define their own rules to avoid some project-specific bugs, without worrying how to implement checkers to enforce the rules. Engler et al.'s extended checker extracts beliefs by tailoring rule templates to a specific system \textemdash for example, finding all functions that fit the rule template, ``$A must be paired with B$''~cite{engler01bugs} and then checks for contradictions and violations. 

As another example, Li et al. developed CP-Miner, an automatic approach to find copy-paste related bugs in large-scale software~\cite{Li2006:CPMiner}. CP-Miner was created based on a prior empirical study~\cite{Chou2001:ESO}, which revealed that under the Linux {\sf drivers/i2o} directory, 34 out of 35 errors were caused by copy-paste or duplicated code. 
One of the major reasons why copy-paste introduces bugs is that, when developers copy code from one location and paste it to another location, they may forget to consistently rename identifiers of variables, functions, and types. CP-Miner first identifies copy-paste code in a scalable way, and then detects bugs associated with copy-paste by checking for specific rules, for example consistent renaming of identifiers. %Many previously unknown bugs in popular operating systems were detected in this way, 49 in Linux and 31 in FreeBSD, meaning that CP-Miner can effectively capture copy-paste related bugs. 
Similarly, FixWizard identifies code clones based on object usage and interactions, recognizes recurring bug-fixes to the clones, and suggests a location and example edit~\cite{Nguyen2010:RBF}. However, it does {\em not generate fixes}.

\subsubsection{Automated Repair.} 
Automatic program repair generates candidate patches and checks correctness using compilation and testing. 

One class of strategies in automatic software repair relies on {\em specifications} or {\em contracts} to guide sound patch generation~\cite{gopinath2011, liblit2011, liu2012, semfix13,Wei:2010:AutoFix-E}. This provides confidence that the output is correct. For example, AutoFix-E~\cite{Wei:2010:AutoFix-E} generates simple bug fixes from manually prescribed contracts. Genetic programming has also been used to co-evolve defect repairs and unit test cases~\cite{Arcuri11,wilkerson2012}; these techniques tend to rely at least in part on formal specifications to define correctness~\cite{arcuriy08,wilkerson11}.  Such techniques struggle to scale, and are usually limited to manually specified code, which is rare in practice.

Another set of techniques uses {\em search-based repair}~\cite{harman07} or predefined repair templates to generate many candidate repairs for a bug, and then validates them using indicative workloads or test suites~\cite{Kim2013:PAR, genprog-icse2012, Perkins09:clearview}. For example, Weimer et al.~generate candidate patches by replicating, mutating, or deleting code \emph{randomly} from the existing program. Many of these approaches can scale to repair defects in large systems with human-competitive costs. However, they tend to find the smallest possible fix for a given failure, and current evidence suggests that humans may find the resulting patches unacceptable in many cases~\cite{genprog-maintainability,Kim2013:PAR}. 

Some automated repair approaches are specialized for particular types of bugs. For example, FixMeUp inserts missing security checks inter-procedurally using a specification, but these additions are very specific and stylized~\cite{son2013fix}.Given concurrency error reports, Jin et al. select from and test a handful of synchronization patterns to fix them~\cite{JZDLL:12} and insert appropriate synchronization into a compiler intermediate representation. Kim et al.'s PAR~\cite{Kim2013:PAR} encode ten common bug fix patterns from Eclipse JDT's version history to improve the patch suggestions of Weimer et al.~\cite{Weimer2009:AFP}. However, the patterns are created manually. 

