\section{Future Directions and Open Problems} 

Software maintenance is challenging and time-consuming. Albeit various research and existing tool support, the global cost of debugging software has risen up to \$312 billion annually~\cite{globalcost}. The cost of software maintenance is rising dramatically and has been estimated as more than 90\% of the total cost for software~\cite{Omnext2010}. Software evolution research still has a long future ahead, because there are still challenges and problems that cost developers a lot of time and manual effort. In this section, we highlight some key issues in change comprehension and suggestion.

\subsection{Change Comprehension}
Understanding software changes made by other people is a difficult task, because it requires not only the domain knowledge of the software under maintenance, but also the comprehension of change intent, and the interpretation of mappings between the program semantics of applied changes and those intent. Existing change comprehension and program differencing tools mainly present the textual or syntactical differences between the before- and after- versions of software changes. Current large-scale empirical studies on code changes also focus on textual or syntactical notion of software changes. However, there is no tool support to automatically summarize the semantics of applied changes, or further infer developers' intent behind the changes. 

The new advanced change comprehension tools must assist software professionals in two aspects. First, by summarizing software changes with a natural language description, these tools must produce more meaningful commit messages when developers check in their program changes to software version control systems (e.g., SVN, Git) to facilitate other people (e.g., colleagues and researchers) to mine, comprehend, and analyze applied changes more precisely~\cite{herzig2013impact}. Second, the generated change summary must provide a second opinion to developers of the changes, and enable them to easily check whether the summarized change description matches their actual intent. If there is a mismatch, developers should carefully examine the applied changes and decide whether the changes reflect realize their original intent. 

To design and implement such advanced change comprehension tools, researchers must address several challenges. 
\begin{enumerate}
\item How should we correlate changes applied in source code, configuration files, and databases to present all relevant changes and their relationships as a whole? For instance, how can we explain why a configuration file is changed together with a function's code body? How are the changes in a database schema correspond to source code changes?
\item How should we map concrete code changes or abstract change patterns to natural language descriptions? For instance, when complicated code changes are applied to improve a program's  performance, how can we detect or reveal that intent? How should we differentiate between different types of changes when inferring change intent or producing natural language descriptions accordingly?
\item When developers apply multiple kinds of changes together, such as refactoring some code to facilitate feature addition, we can we identify the boundary between the different types of changes? How can we summarize the changes in a meaningful way so that both types of changes are identified, and the connection between them is characterized clearly? 
\end{enumerate}
To solve these challenges, we may need to invent new program analysis techniques to correlate changes, new change interpretation approaches to characterize different types of changes,
and new text mining and natural language processing techniques to map changes to natural language descriptions.

\subsection{Change Suggestion}
Compared with understanding software changes, applying changes is even more challenging, and can cause serious problems if changes are wrongly applied. Empirical studies showed that 15-70\% of the bug fixes applied during software maintenance were incorrect in their first release~\cite{Sidiroglou:2007:BP,Yin2011:FBB}, which indicates a desperate need for more sophisticated change suggestion tools. 
Below we discuss some of the limitations of existing automatic tool support, and also suggest potential future directions.


\textbf{Corrective Change Suggestion.} Although various tools are proposed to detect different kinds of bugs or even suggest bug fixes, the suggested fixes are usually relatively simple. They may focus on single-line bug fixes, multiple if-condition updates, missing APIs to invoke, or similar code changes that are likely to be applied to similar code snippets. However, no existing approach can suggest a whole missing \codefont{if}-statement or \codefont{while}-loop, neither can they suggest bug fixes that require declaring a new method and inserting the method invocation to appropriate code locations.

\textbf{Adaptive Change Suggestion}. Existing tools allow developers to migrate programs between specific platforms (e.g., desktop and cloud), or support cross-platform software development which enables \textbf{write once, compile anywhere} (WOCA). However, it is not easy to extend these tools when a new platform becomes available and people need to migration programs from existing platforms to the new one. Specifically, 
with the platform-to-platform migration tools, if we have many platforms (e.g., N), theoretically, we need to build and maintain N * (N-1) migration tools to allow the program migration between any two platforms. Although cross-platform software development tools can significantly reduce the necessity of platform-to-platform migration tools, these tools are limited to the platforms for which they are originally built. When a new platform becomes available, these tools will undergo significant modifications to support the new platform. In the future, we need extensible program migration frameworks, which will automatically infer program migration transformations from the concrete migration changes applied by developers, and then apply the inferred transformations to automate other migration tasks for different target platforms. With such frameworks, developers will not need to manually apply repetitive migration changes. 

\textbf{Perfective Change Suggestion}. There are some programming paradigms developed (e.g., AOP and FOP), which facilitate developers to apply perfective changes to enhance or extend any existing software. However, there is no tool support to automatically suggest what perfective changes to apply and where to apply those changes. The main challenge of creating such tools is that unlike other types of changes, perfective changes usually aim to introduce new features instead of modifying existing features. Without any hint provided by developers, it is almost impossible for any tool to predict what new features to add to the software. However, when developers know what new features they want to add but do not know how to implement those features, some advanced tools can be helpful by automatically searching for relevant open source projects, identifying relevant code implementation for the queried features, or even providing customized change suggestion to implement the features and to integrate the features into existing software.

\textbf{Preventive Change Suggestion}.
Although various refactoring tools can automatically refactor code, all the supported refactorings are limited to predefined behavior-preserving program transformations. It is not easy to extend existing refactoring tools to automate new refactorings, especially when the program transformation involves modifications of multiple software entities (i.e., classes, methods, and fields). Some future tools should be designed and implemented to facilitate the extensions of refactoring capabilities.
There are also some refactoring tools that suggest refactoring opportunities based on code smells or software change history. For instance, if there are many code clones in a codebase, existing tools can suggest a clone removal refactoring to reduce duplicated code. In reality, nevertheless, most of the time developers apply refactorings only when they want to apply bug fixes or add new features, which means that refactorings are more likely to be motivated by other kinds of changes instead of code smells and change history~\cite{Silva2016:WWR}. In the future, with the better change comprehension tools mentioned above, we may be able to identify the trends of developers' change intent in the past, and observe how refactorings were applied in combination with other types of changes. Furthermore, with the observed trends, new tools must be built to predict developers' change intent in future, and then suggest refactorings accordingly to prepare for the upcoming changes.



%\paragraph{Awareness about Software Updates.} 
%enabling programmers to search and filter code changes of interest. 
%supporting investigation and monitoring of program modifications based on the structure, content, and task context of code changes.
%not overload programmers with a large number of change-events or require substantial effort by programmers to specify what they want to monitor. 
%overcome these limitations by automatically inferring awareness-interests and monitoring program changes matching such interests. 
%leverages in-depth automated code change analysis to abstract program differences at a high-level, to determine which subset of changes are refactorings, to reason about {\em interdependence} and {\em interference} among program deltas in order to investigate, search and monitor code changes by their content and structure.  
%leverage automated analysis to help developers manage the impact of other developers' modifications. 
